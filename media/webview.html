<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kelp Branches</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #0d1117;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #2dba4e;
        font-family: monospace;
        font-weight: bold;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        pointer-events: none;
      }
      canvas {
        display: block;
      }
      #config-panel {
        position: absolute;
        bottom: 50px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        padding: 15px;
        border-radius: 8px;
        color: #2dba4e;
        font-family: monospace;
        pointer-events: auto;
        display: flex;
        flex-direction: column;
        gap: 10px;
        width: 220px;
      }
      #branch-panel {
        position: absolute;
        top: 50px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-radius: 8px;
        color: #2dba4e;
        font-family: monospace;
        pointer-events: auto;
        display: none;
        flex-direction: column;
        gap: 5px;
        width: 200px;
        max-height: 300px;
        overflow-y: auto;
      }
      .control-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      .control-group label {
        font-size: 12px;
        display: flex;
        justify-content: space-between;
      }
      .button-group {
        display: flex;
        gap: 10px;
        margin-top: 5px;
      }
      button {
        background: #238636;
        border: 1px solid rgba(240, 246, 252, 0.1);
        color: #ffffff;
        padding: 5px 10px;
        border-radius: 6px;
        cursor: pointer;
        font-family: inherit;
        font-size: 12px;
        flex: 1;
      }
      button:hover {
        background: #2ea043;
      }
      input[type="range"] {
        width: 100%;
        accent-color: #2dba4e;
      }
      .branch-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
      }
      .branch-item input {
        accent-color: #2dba4e;
        width: auto;
        margin: 0;
        cursor: pointer;
      }
      #toggle-config {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: #238636;
        border: 1px solid rgba(240, 246, 252, 0.1);
        color: #ffffff;
        padding: 5px 10px;
        border-radius: 6px;
        cursor: pointer;
        font-family: inherit;
        font-size: 12px;
        width: 250px;
      }
      #toggle-config:hover {
        background: #2ea043;
      }
    </style>
  </head>
  <body>
    <div id="info">Waiting for Git data...</div>
    <div id="branch-panel"></div>
    <div id="config-panel">
      <div class="control-group">
        <label>Text Size <span id="val-text">0.030</span></label>
        <input
          type="range"
          id="textSize"
          min="0.01"
          max="0.1"
          step="0.005"
          value="0.030"
        />
      </div>
      <div class="control-group">
        <label>Zoom <span id="val-zoom">26.0</span></label>
        <input
          type="range"
          id="sceneZoom"
          min="2"
          max="100"
          step="0.5"
          value="26.0"
        />
      </div>
      <div class="control-group">
        <label>Rotate <span id="val-rotate">0.00</span></label>
        <input
          type="range"
          id="sceneRotate"
          min="-3.15"
          max="3.15"
          step="0.05"
          value="0.00"
        />
      </div>
      <div class="control-group">
        <label>X Translate <span id="val-x">20.0</span></label>
        <input
          type="range"
          id="sceneX"
          min="-50"
          max="50"
          step="1"
          value="20.0"
        />
      </div>
      <div class="control-group">
        <label>Y Translate <span id="val-y">0.0</span></label>
        <input
          type="range"
          id="sceneY"
          min="-50"
          max="200"
          step="1"
          value="0.0"
        />
      </div>
      <div class="control-group">
        <label>Z Translate <span id="val-z">0.0</span></label>
        <input
          type="range"
          id="sceneZ"
          min="-50"
          max="50"
          step="1"
          value="0.0"
        />
      </div>
      <div class="control-group">
        <label>Fog <span id="val-fog">0.008</span></label>
        <input
          type="range"
          id="sceneFog"
          min="0"
          max="0.15"
          step="0.001"
          value="0.008"
        />
      </div>
      <div class="button-group">
        <button id="btnFit">Fit Scene</button>
        <button id="btnLeft">Left Align</button>
      </div>
    </div>
    <button id="toggle-config">Hide Config</button>
    <div id="container"></div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      // 1. Scene Setup
      const scene = new THREE.Scene();
      // Add some fog to blend into VS Code background
      scene.fog = new THREE.FogExp2(0x0d1117, 0.008);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
      );
      camera.position.set(5, 5, 10);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const pointLight = new THREE.PointLight(0xffffff, 1);
      pointLight.position.set(10, 10, 10);
      scene.add(pointLight);

      // Controls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 1;
      controls.maxDistance = 500;

      // --- KELP GENERATOR ---
      const nodeGeometry = new THREE.SphereGeometry(0.5, 16, 16);
      const nodeMaterial = new THREE.MeshStandardMaterial({ color: 0x2dba4e });
      const stemMaterial = new THREE.LineBasicMaterial({ color: 0x58a6ff });

      const nodes = [];
      let currentCommits = [];
      let allCommits = [];
      let branchVisibility = new Map();
      let branchTips = new Map();
      let textScale = 0.03;

      // Listen for data from the Extension
      window.addEventListener("message", (event) => {
        const message = event.data;
        if (message.command === "loadCommits") {
          allCommits = message.data;
          extractBranches(allCommits);
          filterAndRender();
        }
      });

      function createTextLabel(text) {
        if (text.length > 40) {
          text = text.substring(0, 40) + "...";
        }
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const fontSize = 24;
        ctx.font = `bold ${fontSize}px monospace`;

        const textWidth = ctx.measureText(text).width;
        canvas.width = textWidth + 20;
        canvas.height = fontSize + 20;

        // Need to set font again after resizing canvas
        ctx.font = `bold ${fontSize}px monospace`;

        ctx.fillStyle = "white";
        ctx.fillText(text, 10, fontSize - 5);

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        const material = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          side: THREE.DoubleSide,
          depthWrite: false,
        });

        const scale = textScale;
        const width = canvas.width * scale;
        const height = canvas.height * scale;
        const geometry = new THREE.PlaneGeometry(width, height);
        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData = { width };
        return mesh;
      }

      function extractBranches(commits) {
        branchTips.clear();
        const newBranches = new Set();

        commits.forEach((c) => {
          if (!c.refs) return;
          const refs = c.refs.split(",").map((r) => r.trim());
          refs.forEach((ref) => {
            let name = ref;
            if (name.startsWith("HEAD -> ")) {
              name = name.replace("HEAD -> ", "");
            }
            if (name.startsWith("tag: ")) return;
            if (name === "HEAD") return;

            branchTips.set(name, c.hash);
            newBranches.add(name);
          });
        });

        const oldVisibility = new Map(branchVisibility);
        branchVisibility.clear();
        newBranches.forEach((b) => {
          if (oldVisibility.has(b)) {
            branchVisibility.set(b, oldVisibility.get(b));
          } else {
            branchVisibility.set(b, true);
          }
        });

        renderBranchPanel();
      }

      function renderBranchPanel() {
        const panel = document.getElementById("branch-panel");
        panel.innerHTML = "";

        if (branchVisibility.size === 0) {
          panel.style.display = "none";
          return;
        }
        panel.style.display = "flex";

        branchVisibility.forEach((visible, name) => {
          const div = document.createElement("div");
          div.className = "branch-item";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = visible;
          checkbox.onchange = (e) => {
            branchVisibility.set(name, e.target.checked);
            filterAndRender();
          };

          const label = document.createElement("span");
          label.innerText = name;
          label.onclick = () => {
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event("change"));
          };

          div.appendChild(checkbox);
          div.appendChild(label);
          panel.appendChild(div);
        });
      }

      function filterAndRender() {
        const visibleHashes = new Set();
        const queue = [];
        const commitMap = new Map();
        allCommits.forEach((c) => commitMap.set(c.hash, c));

        branchVisibility.forEach((visible, name) => {
          if (visible) {
            const hash = branchTips.get(name);
            if (hash && !visibleHashes.has(hash)) {
              visibleHashes.add(hash);
              queue.push(hash);
            }
          }
        });

        while (queue.length > 0) {
          const hash = queue.shift();
          const commit = commitMap.get(hash);
          if (!commit) continue;

          const parents = commit.parents ? commit.parents.split(" ") : [];
          parents.forEach((p) => {
            if (p && commitMap.has(p) && !visibleHashes.has(p)) {
              visibleHashes.add(p);
              queue.push(p);
            }
          });
        }

        const filtered = allCommits.filter((c) => visibleHashes.has(c.hash));
        renderCommits(filtered);
      }

      function renderCommits(commits) {
        currentCommits = commits;
        document.getElementById("info").innerText =
          "ðŸŒ¿ Loaded " + commits.length + " commits";

        // Clear old scene
        nodes.forEach((n) => {
          scene.remove(n);
          if (n.isMesh && n.material.map) {
            n.geometry.dispose();
            n.material.map.dispose();
            n.material.dispose();
          } else if (n.isLine) {
            n.geometry.dispose();
          }
        });
        nodes.length = 0;

        // 1. Sort commits by date (Oldest -> Newest) for processing
        // Git log usually gives Newest -> Oldest
        const sortedCommits = [...commits].reverse();

        // 2. Calculate Positions
        const commitMap = new Map(); // hash -> { x, y, lane }
        const laneTips = new Map(); // laneIndex -> commitHash (last commit in this lane)
        let maxLane = 0;

        sortedCommits.forEach((commit, index) => {
          const yPos = index * 1.5; // Stack upwards based on time
          let lane = 0;

          // Parse parents
          const parents = commit.parents ? commit.parents.split(" ") : [];
          const primaryParentHash = parents[0];

          if (!primaryParentHash || !commitMap.has(primaryParentHash)) {
            // Root commit or parent not found in this batch: start new lane
            // Try to find a free lane or just increment
            lane = maxLane++;
          } else {
            const parentNode = commitMap.get(primaryParentHash);

            // Check if parent's lane is already "continued" by another child
            if (laneTips.get(parentNode.lane) === primaryParentHash) {
              // Continue parent's lane (Vertical growth)
              lane = parentNode.lane;
            } else {
              // Branch off! (45 degree angle effect comes from x change + y change)
              lane = maxLane++;
            }
          }

          const xPos = lane * 2.0; // Spacing between branches

          commitMap.set(commit.hash, {
            x: xPos,
            y: yPos,
            lane: lane,
            data: commit,
          });
          laneTips.set(lane, commit.hash);

          // 1. Create the Sphere (The Commit)
          const sphere = new THREE.Mesh(nodeGeometry, nodeMaterial);
          sphere.position.y = yPos;
          sphere.position.x = xPos;
          scene.add(sphere);
          nodes.push(sphere);

          // 2. Add Text Label
          if (commit.message) {
            const firstLine = commit.message.split("\n")[0];
            const label = createTextLabel(firstLine);
            // Position to the right of the sphere
            label.position.set(xPos + 0.8 + label.userData.width / 2, yPos, 0);
            scene.add(label);
            nodes.push(label);
          }

          // 3. Create Stems (Lines to parents)
          parents.forEach((parentHash) => {
            if (commitMap.has(parentHash)) {
              const parentNode = commitMap.get(parentHash);

              const points = [];
              points.push(new THREE.Vector3(xPos, yPos, 0));
              points.push(new THREE.Vector3(parentNode.x, parentNode.y, 0));

              const stemGeo = new THREE.BufferGeometry().setFromPoints(points);
              const line = new THREE.Line(stemGeo, stemMaterial);
              scene.add(line);
              nodes.push(line);
            }
          });
        });

        // Adjust camera to look at the middle of the stalk
        const centerY = commits.length * 0.75;
        // Center X based on max lanes
        const centerX = (maxLane * 2.0) / 2;

        camera.position.set(centerX, centerY, 40);
        controls.target.set(centerX, centerY, 0);
        controls.update();
        syncSliders();
      }

      // UI Event Listeners
      document.getElementById("textSize").addEventListener("input", (e) => {
        textScale = parseFloat(e.target.value);
        document.getElementById("val-text").innerText = textScale.toFixed(3);
        if (currentCommits.length) renderCommits(currentCommits);
      });

      // Scene Manipulation Sliders
      const zoomSlider = document.getElementById("sceneZoom");
      const rotateSlider = document.getElementById("sceneRotate");
      const xSlider = document.getElementById("sceneX");
      const ySlider = document.getElementById("sceneY");
      const zSlider = document.getElementById("sceneZ");
      const fogSlider = document.getElementById("sceneFog");

      function updateSceneFromSliders() {
        const zoom = parseFloat(zoomSlider.value);
        const rotate = parseFloat(rotateSlider.value);
        const x = parseFloat(xSlider.value);
        const y = parseFloat(ySlider.value);
        const z = parseFloat(zSlider.value);
        const fog = parseFloat(fogSlider.value);

        // Update Target (Translate)
        const deltaX = x - controls.target.x;
        const deltaY = y - controls.target.y;
        const deltaZ = z - controls.target.z;
        controls.target.x = x;
        controls.target.y = y;
        controls.target.z = z;
        camera.position.x += deltaX;
        camera.position.y += deltaY;
        camera.position.z += deltaZ;

        // Update Fog
        scene.fog.density = fog;

        // Update Rotation and Zoom (Spherical relative to target)
        const offset = new THREE.Vector3().subVectors(
          camera.position,
          controls.target,
        );
        const spherical = new THREE.Spherical().setFromVector3(offset);

        spherical.radius = zoom;
        spherical.theta = rotate;

        offset.setFromSpherical(spherical);
        camera.position.copy(controls.target).add(offset);

        controls.update();
        updateLabels();
      }

      function syncSliders() {
        // Don't sync if user is currently dragging a slider
        if (document.activeElement && document.activeElement.type === "range")
          return;

        const offset = new THREE.Vector3().subVectors(
          camera.position,
          controls.target,
        );
        const spherical = new THREE.Spherical().setFromVector3(offset);

        zoomSlider.value = spherical.radius;
        rotateSlider.value = spherical.theta;
        xSlider.value = controls.target.x;
        ySlider.value = controls.target.y;
        zSlider.value = controls.target.z;
        fogSlider.value = scene.fog.density;

        updateLabels();
      }

      function updateLabels() {
        document.getElementById("val-zoom").innerText = parseFloat(
          zoomSlider.value,
        ).toFixed(1);
        document.getElementById("val-rotate").innerText = parseFloat(
          rotateSlider.value,
        ).toFixed(2);
        document.getElementById("val-x").innerText = parseFloat(
          xSlider.value,
        ).toFixed(1);
        document.getElementById("val-y").innerText = parseFloat(
          ySlider.value,
        ).toFixed(1);
        document.getElementById("val-z").innerText = parseFloat(
          zSlider.value,
        ).toFixed(1);
        document.getElementById("val-fog").innerText = parseFloat(
          fogSlider.value,
        ).toFixed(3);
      }

      [zoomSlider, rotateSlider, xSlider, ySlider, zSlider, fogSlider].forEach(
        (el) => {
          el.addEventListener("input", updateSceneFromSliders);
        },
      );

      // Sync sliders when mouse interacts with scene
      controls.addEventListener("change", syncSliders);

      // Toggle Config Panel
      const configPanel = document.getElementById("config-panel");
      const toggleBtn = document.getElementById("toggle-config");
      toggleBtn.addEventListener("click", () => {
        if (configPanel.style.display === "none") {
          configPanel.style.display = "flex";
          toggleBtn.innerText = "Hide Config";
        } else {
          configPanel.style.display = "none";
          toggleBtn.innerText = "Show Config";
        }
      });

      document.getElementById("btnFit").addEventListener("click", () => {
        if (!currentCommits.length) return;
        const centerY = currentCommits.length * 0.75;
        camera.position.set(10, centerY, currentCommits.length * 1.5);
        controls.target.set(0, centerY, 0);
        controls.update();
        syncSliders();
      });

      document.getElementById("btnLeft").addEventListener("click", () => {
        if (!currentCommits.length) return;
        const centerY = currentCommits.length * 0.75;
        camera.position.set(10, centerY, currentCommits.length * 1.5);
        // Look to the right (positive X) so the scene (at X=0) appears on the left
        controls.target.set(8, centerY, 0);
        controls.update();
        syncSliders();
      });

      // 3. Animation Loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      // Handle Resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
