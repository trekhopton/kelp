<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kelp Branches</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #0d1117;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #2dba4e;
        font-family: monospace;
        font-weight: bold;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        pointer-events: none;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="info">Waiting for Git data...</div>
    <div id="container"></div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      // 1. Scene Setup
      const scene = new THREE.Scene();
      // Add some fog to blend into VS Code background
      scene.fog = new THREE.FogExp2(0x0d1117, 0.05);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
      );
      camera.position.set(5, 5, 10);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const pointLight = new THREE.PointLight(0xffffff, 1);
      pointLight.position.set(10, 10, 10);
      scene.add(pointLight);

      // Controls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 1;
      controls.maxDistance = 500;

      // --- KELP GENERATOR ---
      const nodeGeometry = new THREE.SphereGeometry(0.5, 16, 16);
      const nodeMaterial = new THREE.MeshStandardMaterial({ color: 0x2dba4e });
      const stemMaterial = new THREE.LineBasicMaterial({ color: 0x58a6ff });

      const nodes = [];

      // Listen for data from the Extension
      window.addEventListener("message", (event) => {
        const message = event.data;
        if (message.command === "loadCommits") {
          renderCommits(message.data);
        }
      });

      function createTextLabel(text) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const fontSize = 24;
        ctx.font = `bold ${fontSize}px monospace`;

        const textWidth = ctx.measureText(text).width;
        canvas.width = textWidth + 20;
        canvas.height = fontSize + 20;

        // Need to set font again after resizing canvas
        ctx.font = `bold ${fontSize}px monospace`;

        ctx.fillStyle = "white";
        ctx.fillText(text, 10, fontSize - 5);

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        const material = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          side: THREE.DoubleSide,
          depthWrite: false,
        });

        const scale = 0.05;
        const width = canvas.width * scale;
        const height = canvas.height * scale;
        const geometry = new THREE.PlaneGeometry(width, height);
        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData = { width };
        return mesh;
      }

      function renderCommits(commits) {
        document.getElementById("info").innerText =
          "ðŸŒ¿ Loaded " + commits.length + " commits";

        // Clear old scene
        nodes.forEach((n) => {
          scene.remove(n);
          if (n.isMesh && n.material.map) {
            n.geometry.dispose();
            n.material.map.dispose();
            n.material.dispose();
          } else if (n.isLine) {
            n.geometry.dispose();
          }
        });
        nodes.length = 0;

        // Render commits as a stack
        // index 0 is the latest commit (HEAD), so it goes at the top
        commits.forEach((commit, index) => {
          const yPos = (commits.length - index) * 1.5; // Stack upwards

          // 1. Create the Sphere (The Commit)
          const sphere = new THREE.Mesh(nodeGeometry, nodeMaterial);
          sphere.position.y = yPos;
          sphere.position.x = Math.sin(yPos * 0.5) * 0.5; // Slight spiral
          scene.add(sphere);
          nodes.push(sphere);

          // 2. Add Text Label
          if (commit.message) {
            const firstLine = commit.message.split("\n")[0];
            const label = createTextLabel(firstLine);
            // Position to the right of the sphere
            label.position.set(
              sphere.position.x + 0.8 + label.userData.width / 2,
              yPos,
              0,
            );
            scene.add(label);
            nodes.push(label);
          }

          // 3. Create the Stem connection to the next node
          if (index < commits.length - 1) {
            const nextY = (commits.length - (index + 1)) * 1.5;
            const points = [];
            points.push(new THREE.Vector3(Math.sin(yPos * 0.5) * 0.5, yPos, 0));
            points.push(
              new THREE.Vector3(Math.sin(nextY * 0.5) * 0.5, nextY, 0),
            );

            const stemGeo = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(stemGeo, stemMaterial);
            scene.add(line);
            nodes.push(line);
          }
        });

        // Adjust camera to look at the middle of the stalk
        const centerY = commits.length * 0.75;
        camera.position.set(10, centerY, commits.length * 1.5);
        controls.target.set(0, centerY, 0);
        controls.update();
      }

      // 3. Animation Loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      // Handle Resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
